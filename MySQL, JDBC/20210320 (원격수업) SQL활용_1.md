**데이터베이스**

**데이터베이스의 개념**

어느 한 조직의 다양한 응용 프로그램들이 공동으로 사용하는 데이터들을 통합하여 저장한 운영 데이터의 집합
- 공용(Shared), 통합(Integrated), 저장(Stored), 운영(Operational) 데이터
  1) 통합된 데이터란?
    - 한 조직 내에서 여러 부서가 유사한 데이터 집합을 사용함
    - 여러 부서가 사용하는 데이터를 통합하여 중복성을 없애고 일관성을 유지함
    - 각 부서가 데이터를 따로 가지고 있으면, 검색이나 운영 시에 편리함
- 데이터베이스의 특징
  1) 실시간 접근성(Real-Time Accessibility)
    - 질의에 대한 실시간 처리 및 응답
  2) 계속적인 변화(Continuous Evolution)
    - 갱신, 삽입, 삭제 : 동적 특성
  3) 동시 공용(Concurrent Sharing)
    - 여러 사용자가 동시에 사용함
  4) 내용에 의한 참조(Content References)
    - 위치나 주소가 아닌 값에 따라 참조함
    - 내용에 의한 참조란?
      - 프로그래밍 언어
      - 주소에 의한 검색 - 특정 메모리 위치에 있는 값을 알려줌
      - 변수 - 메모리 주소 대신 특정이름으로 x, idx 등으로 표시해 놓으면 기억하기 좋음
      - 데이터베이스에서의 검색
      - ex) 학번이 100인 학생의 이름을 검색하라
            SQL: SELECT NAME 
                 FROM STUDENT
                 WHERE STUDENTNUM = 100

**데이터베이스 관리 시스템**

**데이터베이스 관리 시스템의 정의**

- 데이터베이스 관리 시스템 (Database Management System(DBMS)
  - 데이터베이스를 생성 및 관리해주는 기능을 제공하는 소프트웨어 패키지/시스템
  - 데이터와 응용 프로그램 사이의 중계자
  - 모든 사용자와 응용 프로그램들이 데이터베이스를 공유할 수 있도록 지원해주는 범용 목적의 소프트웨어 시스템
- 데이터베이스 시스템
  - DB+DBMS+응용프로그램
  - 데이터베이스, DBMS, 데이터베이스 시스템을 혼용해서 사용함
- 데이터베이스 관리 시스템의 기능
  1) 데이터 정의 기능
    - 여러 사용자의 데이터를 통합하여 저장하고 공유할 수 있도록 데이터 모델에 따라서 정의하는 기능
  2) 데이터 조작 기능
    - 사용자와 데이터베이스 간의 의사소통
    - 데이터베이스의 접근 및 조작 기능 제공
      - 삽입, 삭제, 변경 및 검색
  3) 데이터 제어 기능
    - 데이터 일관성(Consistency), 무결성(Integrity), 보안(Securrity)을 유지하는 기능
      - 백업과 파손 회복 
      - 인증과 보안 
      - 병행제어
- 현재 가장 많이 쓰이는 데이터베이스 관리 시스템 
  - 3세대 : 객체 관계형 데이터베이스 관리 시스템(2세대 DBMS + 3세대 DBMS ORDBMS)
---------------------------------------------------------------------------------------------------------------
**관계형 데이터 모델**

**관계형 데이터 모델의 구조와 연산**

- Structure 구조
  - 데이터의 구조
    - 정적 성질, 개체 타입과 이들 간의 관계를 명세함
- Operation 연산
  - 데이터의 동적 성질 
    - 개체 인스턴스를 처리하는 작업에 대한 명세
    - 데이터 조작 기법
- Constraint 제약조건
  - 데이터의 논리적 제약
    - 구조로부터 파생, 의미적 제약
    - 데이터 조작의 한계를 표현한 규정

- 관계형 데이터 모델을 사용하는 이유
  - 모델의 구조가 단순함
  - 집합 이론(Set Theory)이라는 수학적 이론에 기반하여 모델이 강건(Sound)함
  - SQL이라는 간단한 비절차적 언어로 사용하기 쉬움
- 관계형 데이터 모델
  - 구조
    - 릴레이션(또는 테이블)
  - 연산
    - 관계 대수(Relation Algebra)
  - 제약조건
    - 무결성(Integiry) 제약 조건

- 관계형 데이터 모델의 구조
  - 릴레이션
  - 2차원 테이블
  - 테이블의 행(Row) >> 튜플
    - 릴레이션의 튜플들의 집합
  - 테이블의 열(Column) >> 속성(Attribute)
    - 도메인(Domain) : 속성이 가질 수 있는 값의 범위

  - 릴레이션의 특징
    1) 튜플의 유일성
      - 릴레이션은 튜플의 집합임
      - 집합은 중복을 허용하지 않음
    2) 튜플의 무순서성
      - 릴레이션은 튜플의 집합임
      - 집합에서 원소들 간의 순서는 없음
    3) 속성(Attribute)의 무순서성
      - 릴레이션 스키마는 속성들의 집합임
    4) 속성(Attribute)의 원자성(Atomicity)
      - 속성(Attribute)의 값은 원자값임
      - 논리적으로 더 분해할 수 없음
 
- 관계형 데이터 모델의 연산
  - 관계 대수(Relational Algebra)
  - 관계 대수와 SQL
    - 관계 대수 >> 시스템 관점
    - SQL >> 사용자 위주
  - 관계 대수 연산자의 분류
    - 일반 집합 연산자
      - 합집합(UNION, U)
      - 교집합(INTERSECT, n)
      - 차집합(DIFFERENCE, -)
      - 카티션 프로덕트(CARTESIAN PRODUCT, X)
    
      - 합병호환성
      - U, n, - 연산의 피연산자(릴레이션)들이 지켜야 할 제약조건
        1) 차수(Degree : 속성의 수)가 같아야 함
        2) 대응되는 속성(Attribute) 쌍 별로 타입(또는 도메인)이 같아야 함
        3) 대응되는 속성(Attribute) 쌍 별로 의미(Semantic)가 같아야 함
        > 1), 2) 조건의 시스템에서 확인해줌
        > 3) 조건은 사람이 해야 함
        
  - 관계 대수 연산자의 분류
    - 순수관계 연산자
      - 정의: 릴레이션이 2차원 구조이기 때문에 유도되는 연산자
      - 셀렉트(SELECT, 시그마)
        - 사용자가 원하는 Tuple(수평적 부분 집합)을 찾아내는 연산자
      - 프로젝트(PROJECT, 파이)
        - 특정 속성(수직적 부분 집합)을 뽑아내는 연산자
        - 프로젝트의 결과는 선택 조건을 만족하는 릴레이션의 수직적 부분집합(Vertical Subset) 
          - 폐쇄성질
          - 중복된 튜플들은 제거됨
      - 조인(JOIN, 삼각형 꼭지점 두개 맞닿아 있는...)
        - 서로 다른 두 연산자를 어떻게 결합할 것인가
        - ex) 학생 테이블에서 학번이 100번인 학생의 지도교수 3번의 이름을 찾아내시오
        - 학생과 교수를 조인해서 학번이 100번인 학생을 찾고, 지도교수 3번의 이름을 뽑아냄
          - 자연 조인
            - 일반적으로 아무 말 없이 조인이라고 하면 "자연 조인"을 말함
            - 두 테이블에 공통으로 나타나는 속성에 대한 동등 조인으로 간주
      - 디비전(DIVISION, 나누기)
      
- 관계형 데이터 모델의 제약조건
  - 키(Key)
    - 키(Key)의 개념
      - 하나의 테이블 내에서 각 튜플의 유일하게 식별할 수 있는 속성들의 집합
        - 실생활의 키
          - 하나의 자물쇠를 열 수 있는 열쇠(키)는 오직 하나임
          - 생활의 편리성을 위하여 키를 복제하여 쓰지만 논리적으로는 하나임
    - 후보키(Candidate Key)
      - 한 릴레이션 R에 대한 속성의 집합으로 다음과 같은 성질을 만족함
      - 유일성(Uniqueness)
        - 서로 다른 두 튜플의 속성집합 K의 값은 같지 않음
      - 최소성(Minimality)
        - K는 서로 다른 두 튜플을 식별하기 위한 최소한의 속성들로만 이루어져 있음
    - 슈퍼키(Super Key)
      - 유일성을 만족하는 속성 집합
      - 최소성을 만족하지 않아도 됨
      - 일반적으로 후보키는 슈퍼키의 부분 집합임 <> 슈퍼키는 후보키를 포함함
    - 기본키(Primary Key)
      - 하나의 릴레이션에는 후보키가 여러 개 있을 수 있음
      - 여러 개의 후보키 중 DBA가 지정한 하나의 키임
    - 대체키(Alternative Key)
      - 후보키 중 기본키를 제외한 나머지 후보키
    - 외래키(Foreign Key)
      - 한 릴레이션 R1의 튜플과 다른 릴레이션 R2의 하나의 튜플과의 연관 관계를 표시하기 위하여 사용함
      - R1의 속성집합 FK의 도메인이 R2의 기본키 일 때, FK를 R1의 외래키라 함
      - R1을 참조 릴레이션, R2를 피참조 릴레이션이라고 함
        - R1과 R2가 다른 릴레이션일 필요는 없음
  
  - 무결성 제약조건
    - 개체 무결성
      - 의미: 서로 다른 두 튜플은 같을 수 없음
      - 정의: 기본키 값은 언제고 어느 때고 NULL 값일 수 없음
    - 참조 무결성
      - 외래키 값은 피참조 릴레이션의 기본키 값이거나 NULL 값임
      - 추가 지정을 통해 NULL을 가질 수 없다고 제약을 걸 수 있음
    - 도메인 무결성
      - 속성 값은 해당 속성 도메인에 속한 값들 중 하나이어야 함
        - EX) 대학생의 학년 도메인: 1,2,3,4 >> 9학년 또는 10학년은 존재할 수 없음
      - DBMS는 데이터베이스의 상태 변화(삽입, 갱신, 삭제)에도 항상 무결성 제약조건을 검사하고 유지시킴
---------------------------------------------------------------------------------------------------------------
**SQL의 개념과 T-SQL**

**SQL의 역사와 특징**

- SEQUEL(Structured English Query Language)
  - 최초의 관계형 데이터베이스 관리 시스템 프로토타입인 SystemR을 위한 데이터베이스 언어로 개발됨
- SQL
  - 1986년 ANSI에서 관계형 데이터베이스 표준언어로 인증

- SQL의 특징
  1. SQL은 무엇인가?
    - 종합 데이터베이스 언어 >> 데이터 정의(DDL), 조작(DML), 제어(DCL)
      > 무엇(What)을 표시하며 어떻게(How)는 표시하지 않음
      > 어떻게는 DBMS가 알아서 처리함
  2. 왜 관계 대수식 대신 SQL을 사용하는가?
    - 관계 대수식 연산자 기호는 키보드로 표기하기 어려움

  3. 관계 대수식(Relational Algebra)와 SQL과의 차이점은 무엇인가?
    - 관계 대수식
      - Relation
      - 튜플의 집합(Set)
        - 집합은 폐쇄성질 가짐
      - 중복을 허용하지 않음
    - SQL
      - 튜플의 백(Bag)
      - 튜플들 간의 순서는 없으나 중복을 허용함
        - 집합을 유지하려면 SQL의 결과에서 항상 중복되는 내용을 제거해야 함
        - 중복을 제거하는 것 = 튜플을 정렬(Sorting)하는 것과 같은 문제임
        - 결과 생성 시 시간이 오래 걸림 >> 성능 문제 발생
      
- SQL 기본 구문
  - DDL문: 데이터 정의문
    - 테이블 생성: CREATE 문
      CREATE TABLE 테이블명
      (속성명 속성타입 [제약조건],
       속성명 속성타입,
       ...
      )
      - 제약조건: NOT NULL, PRIMARY KEY, UNIQUE
    
    - 테이블 삭제: DROP문
      DROP TABLE 테이블명
      
    - 테이블 구조 변경: ALTER문
      - 속성 추가
        ALTER TABLE 테이블명(ADD 속성명 속성타입)
      - 속성 제거
        ALTER TABLE 테이블명(DROP 속성명 속성타입)
      - 속성 타입 변경
        ALTER TABLE 테이블명(ALTER 속성명 속성타입)
  
  - DML문: 데이터 조작문
    - 튜플 삽입: INSERT 문
      INSERT INTO 테이블명(속성명, 속성명, ...)
      VALUES (속성값, 속성값, ...)
    
    - 튜플 변경: UPDATE문
      UPDATE (업데이트하고자 하는)테이블명
      SET 속성명 = 수식
      [WHERE 조건]
      
    - 튜플 삭제: DELETE문
      DELETE FROM 테이블명
      [WHERE 조건]
      
    - 트랜잭션 관련
      SELECT 속성명, 속성명, ...
      FROM 테이블명
      [WHERE 조건]
      
  - DCL문: 데이터 제어문
    - 트랜잭션 관련
      - COMMIT : 어떤 일을 완료해라
      - ROLLBACK : 완료한 트랜잭션을 취소하시오
        
    - 사용자 권한 제어 관련
      - GRANT : 어떤 사용자한테 권한을 부여
      - REVOKE : 부여한 권한을 취소
      - DENY : 어떤 사람한테 이건 하지 못한다 할 수 없다 거절해야된다 개념을 제공하는 문법

- MS-SQL
  - Oracle : 우리나라에서 제일 많이 사용
  - MySQL : 오픈소스로 많이 사용하고 있음
  - MS-SQL Editions
    - MS-SQL Server
      - Microsoft에서 제공하는 데이터베이스 관리 시스템
      - Edition 종류
        - Express, Workgroup, Standard, Enterprise

****** 참고!!! 본 수업에서는 MySQL을 이용하나 현재 원격수업에서는 MS-SQL 이용... ******
---------------------------------------------------------------------------------------------------------------
**데이터 구조 생성과 변경**

**데이터베이스 생성**

- 데이터베이스 - 밥상
 - 테이블(그릇)을 올리기 전에 데이터베이스(밥상)부터 만들어야 함
- MS-SQL에서 데이터베이스 만들기
  - T-SQL(Transact-SQL) : Text입력
  - SSMS(SQL Server Management Studio) : GUI 이용

- T-SQL을 이용하여 데이터베이스 만들기
 - DB 이름: test01
 - 사용자 DB를 생성하려면, master DB를 사용해야 함
  - USE master
  - CREATE DATABASE test01
- SSMS를 이용하는 방법(GUI 이용)
  - DB 이름: test02
  - 논리적 DB >>> 물리적 파일
    - .mdf (for data), .ldf (for log), .ndf (for large DB -optional)

**기본 데이터 타입**

- DB(밥상)를 만들었으면 테이블(밥그릇)을 만들어야 함
- 어떤 모양의 테이블을 만들까?
  - MS=SQL에서 제공하는 기본 속성 타입

- 숫자 타입
  - bit : 1 bit
  - tinyint : 0~255 (정수)
  - smallint : -2^15~2^15-1 (정수) -16비트 사용해서 -2의 15승 에서 2의 15승 -1 까지의 값을 가질 수 있음
  - int : -2^31 ~ 2^31-1 (정수) -32비트를 사용
  - bigint : -2^63 ~ 2^63-1 (정수) -64비트 사용, 가장 정확하고 큰 값을 표현하는 정수형
  - decimal[p[,s])[, numeric([p[,s])] : deciaml(5,2) >>> 123.45 -
    - 소수점 표현, 
    - decimal(5,2) 경우: (전체자리 수가 다섯개인데, 소수점 이하 2자리까지 표시하시오 라는 의미)
  - float : 4byte, 8byte float(실수) 부동소수점 형태
  - real : 4byte float(실수) 부동소수점 형태

- 날짜(시간) 타입
  - datetime : 1755/1/1 ~ 9999/12/31 (8byte) (날짜)
  - smalldatatime : 1990/01/01 ~ 2079/6/6 (4byte) (날짜)

- 문자 타입
  - char[(n)] : 고정 길이 문자열
  - varchar[(n)] : 가변 길이 문자열
  - nchar[(n)] : for unicode(2byte) >> n >> 2n bytes
    - (유니코드를 위한 고정 문자열)
  - nvarchar[(n)] : for unicode(유니코드를 위한 가변 길이 문자열)

- IDENTITY
  - 자동 증가 속성 타입
  - IDENTITY(10,2) >> 초기값 10, 2씩 증가
    - 10, 12, 14, ...

**테이블 생성과 튜플 추가**

- 테이블의 생성
  - CREATE TABLE 테이블명
    (속성명 속성타입 [제약조건],
     속성명 속성타입,
     ...
    )
  
- 튜플 추가
  - INSERT INTO 테이블명(속성명, 속성명, ...)
    VALUES (속성값, 속성값, ...)
    - INTO는 생략 가능
    - id 속성은 자동 증가 타입이므로 값을 지정할 수 없음

- 추가된 튜플의 검색
  - SELECT 속성명, 속성명, ... (모든 속성 볼 때는 SELECT * FROM 테이블명)
    FROM 테이블명
    [WHERE 조건]

- SSMS를 이용한 테이블 만들기
  - 테이블 선택(마우스 오른쪽 버튼 선택)
  - 속성 이름과 타입 선택
  - 테이블 이름 입력

**테이블 변경**

**ADD, ALTER, DROP column**
- 테이블의 구조 변경(ALTER TABLE)
  - ADD column : 속성 추가
  - ALTER column : 속성 타입 변경
  - DROP column : 속성 제거
    - ALTER TABLE 테이블명{
      {ADD|ALTER|DROP} [COLUMN] 속성명 [타입]
      }
    - 주의 사항
      - ALTER column의 경우 속성값의 범위를 증가시키는 경우에는 문제가 없지만
        범위를 감소시킬 경우에는 현재 테이블이 저장된 속성값들에 따라서 허용이 안될 수도 있음
      - ex) 이름 속성값으로 "김이름씨", "박이름씨", "이름이이뻐요"등이 저장되어 있을 때
      - 속성 타입은 varchar(3)로 변경하려고 하면 안됨
        > 모두 6byte 이상임(한글 1자는 2byte)
      - varchar(50)으로는 변경 가능함

  - ADD column : 속성 추가
    - datatime형으로 pdate속성을 memberTEST 테이블에 추가함
      ALTER TABLE memberTEST
      ADD pdate datetime

  - ALTER column : 속성 타입 변경
    - name 속성의 타입을 varchar(30)으로 변경함
      ALTER TABLE memberTEST
      ALTER column name varchar(30)
      
- SSMS에서 테이블의 구조를 보는 방법
  1) 테이블 선택(마우스 오른쪽 버튼 클릭)
  2) 디자인 선택

**Drop table과 TRUNCATE table**

- 테이블을 지우기
  - DROP TABLE table_name
- 테이블의 모든 내용을 지우기, 단 테이블은 남기기
  - TRUNCATE TABLE table_name
- 주의사항
  - CREATE, ADD, ALTER, DROP, TRUNCATE 등은 모두 데이터 정의어(DDL)임
  - 명령문이 수행되고 나면 회복이 불가능함
---------------------------------------------------------------------------------------------------------------
**제약조건**

**데이터 무결성**

- NOT NULL
  - NULL 값 허용 불가
    ex) 학생 테이블에서 학생의 이름은 NULL값일 수 없음
- UNIQUE
  - 하나의 테이블 내에서 한번만 나옴
  - 주로 대체키 설정 시 사용됨

- PRIMARY KEY
  - 기본키
  - 의미: UNIQUE + NOT NULL
- FOREIGN KEY
  - 외래키
- CHECK 
  - 한정 지을 때 사용
  - 도메인 무결성

**제약조건의 설정**

- 테이블을 만들 때 속성에 제약 조건 지정하기
  CREATE TABLE 테이블명
  (속성명 속성타입 [[제약조건명] 제약조건],
   속성명 속성타입,
   ...
  )
  - ex) name varchar(20) NOT NULL
        id int CONSTRAINT PK_01 PRIMARY KEY
      
- 제약조건 위반 튜플 삽입 예
  INSESRT INTO customer
  VALUES(NULL, '2222', 'Lee', '010', '1234567', 1979, 'Seoul)
    - Cannot insert the value NULL into column 'id' 에러메시지 발생
    - 제약조건이 Null 값일 경우 제약조건 위반으로 값을 추가할 수 없음

- 참조 무결성 제약조건
  - 외래키 값은 다른 테이블의 기본키 값들 중에 하나이어야 함
    ex) 사원 테이블의 부서번호는 부서 테이블의 기본키 값들 중 하나이어야 함
    속성명 [CONSTRAINTS 제약조건명]
    REFERENCE 참조테이블명(속성명)
    
- 참조 무결성 설정 및 삽입 오류의 예
![20210320_142948](https://user-images.githubusercontent.com/78403443/111860125-be86e080-8988-11eb-8b46-e2f68e5dfbe6.png)
  -  

- Check 제약조건
  - 도메인 무결성 제약조건
    - 입력 값의 제한
      ex) birthYear int CHECK(birth Year >= 1900)
          Age int CHECK(Age between 1 and 150)

- 테이블 수준 제약조건
  - 속성 단위로 제약조건 설정은 표현에 있어서 제약이 따름
    - 복합키의 경우(여러 개의 속성이 합쳐져서 키가 됨) 등
    - 구문
      CREATE TABLE 테이블명(
      속성명 속성타입
      ...
      [CONSTRAINT 제약조건명] 제약조건(속성명)
      )
- 테이블 수준 제약조건 설정의 예      
![20210320_144308](https://user-images.githubusercontent.com/78403443/111860414-9a2c0380-898a-11eb-81b8-e0d720d38344.png)
![20210320_144716](https://user-images.githubusercontent.com/78403443/111860486-2dfdcf80-898b-11eb-8cff-89cf66e910e3.png)
  
**제약조건의 추가 및 제거**

- 테이블을 생성한 후에 제약조건을 추가하거나 제거할 필요성이 있음
  - 제약조건도 테이블의 구조 정보에 속함으로 ALTER TABLE을 이용함
  - 추가
    - ADD CONSTRAINT
  - 제거
    - DROP CONSTRAINT

- 제약조건 이름을 지정해 두어야 추가나 제거가 쉬움
- 추가
  - ALTER TABLE 테이블명
    ADD [CONSTRAINT 제약조건명] 제약조건 (속성명)
- 제거 
  - ALTER TABLE 테이블명
    DROP CONSTRAINT 제약조건명
    
- 제약조건 변경 예
![20210320_145253](https://user-images.githubusercontent.com/78403443/111860600-00655600-898c-11eb-8550-454e007d0401.png)
------------------------------------------------------------------------------------------------------------------------------
**데이터 검색**

**AS 키워드와 "*"**

- 실습용 데이터 생성
  - 실습을 위한 테이블 및 튜플들을 생성함
    - 5SQLDatapopulate.sql
    - DB 이름: MagicCorp
    - 테이블: DEPARTMENT, EMPLOYEE, SALGRADE
  
- 무조건 검색
  - SELECT 속성명1, 속성명2, ...
    FROM 테이블명
  - 모든 부서 정보 검색
    - USE MagicCorp
      GO
      SELECT DNO, DNAME, LOC FROM DEPARTMENT
      
- *
  - 모든 속성명을 쓰기 힘듦
    - "*"을 사용함
    - SELECT절에서 *는 모든 속성이란 의미임
    - 모든 부서 정보 검색
      - SELECT * FROM DEPARTMENT        

- AS 키워드
  1) 질의 결과의 속성명을 바꾸어서 나타나게 함
  2) 질의결과에 수식을 넣을 수 있음
  3) 속성명이 없음
  4) AS 키워드로 속성명을 부여함

**무조건 검색**
  - Q. 사원테이블에서 사원명과 봉급*12 검색
  ![20210320_153025](https://user-images.githubusercontent.com/78403443/111861386-378a3600-8991-11eb-8473-8794fb3cbb17.png)

**간단한 데이터 검색**

**간단한 조건 검색**

  - WHERE 절
    - Q. 사원 테이블(EMPLOYEE)에서 사원번호(ENO) 110번의 이름(ENAME)과 부서번호(DNO)검색
      - 조건: 사원번호 110번
      - WHERE 절을 사용함
        - SELECT ENAME, DNO
          FROM EMPLOYEE
          WHERE ENO = 110

    - 비교 연산자
      - WHERE 절에서 문자, 숫자, 날짜의 크기나 순서를 비교함
        - 같다 : =
        - 같지 않다 : !=, <>
        - 크다 : >
        - 크거나 같다 : >=
        - 작다 : <
        - 작거나 같다 : <=

    - 논리 연산자
      - WHERE 절에서 여러 개의 조건을 결합할 경우
        - X AND Y : X, Y가 참일 때 참을 반환
        - X OR Y : X나 Y가 참일 때 참을 반환
        - NOT X : X가 거짓일 때 참을 반환
  
    - Q. 사원 테이블에서 부서번호(DNO)가 20번이고 봉급(SALARY)이 400이상인 사원의 이름(ENAME)과 직책(JOB) 검색
      - 조건: DNO = 20 AND SALARY >= 400
      - SELECT ENAME, JOB FROM EMPLOYEE
        WHERE DNO = 20 AND SALARY >= 400

  - DISTINCT
    - SQL은 Bag 을 기반으로 함
      - 중복된 것들도 다 나옴
    - 중복된 것을 제거하고 한번만 나오게 하는 방법
      - DISTINCT를 사용함
        ex) SELECT DISTINCT 속성명 ...
    - Q. 사원 테이블에서 모든 직급(JOB)검색
      - SELECT JOB from EMPLOYEE
    - Q. 사원 테이블에서 모든 직급을 중복 없이 검색
      - SELECT DISTINCT JOB from EMPLOYEE
  
**복잡한 데이터 검색**

**BETWEEN, IN, IS NULL**

- BETWEEN a AND b
  - 검색 조건의 상한과 하한을 지정함
    - 속성 X가 10보다 크거나 같고 50보다 작거나 같음
    - X >= 10 AND X <= 50
      - X BETWEEN 10 AND 50
    - Q. 사원 테이블에서 봉급이 400보다 크거나 같고 600보다는 작거나 같은 사원들의 정보 검색
      - SELECT * FROM EMPLOYEE
        WHERE SALARY BETWEEN 400 AND 600

- IN(a, b, c, ...)
  - 속성값이 a, b, c, ... 중 하나라도 일치하면 참
    - 속성 X가 10이거나 20이거나 30임
    - X = 10 OR X = 20 OR X = 30
      - X IN(10, 20, 30)

    - Q. 직급이 'section'이거나 'senior'인 사원들의 이름과 직급 검색
      - SELECT ENAME, JOB FROM EMPLOYEE
        WHERE JOB IN ('section', 'senior')
        
- IS NULL
  - NULL 값은 어떤 비교를 하든 거짓임
    - 사원 테이블에서 COMMISSION 값이 NULL인 튜플들이 있을 경우
      ![20210320_160321](https://user-images.githubusercontent.com/78403443/111862019-cf8a1e80-8995-11eb-9c09-b96e79bd8639.png)
      1) X = NULL >>> X가 NULL 값이어도 이 결과는 거짓
      2) 결과가 없음     
      ![20210320_160601](https://user-images.githubusercontent.com/78403443/111862078-2f80c500-8996-11eb-90f3-70dcb8e745ba.png)
      >>> IS NULL을 이용함
      >>> SELECT * FROM EMPLOYEE
          WHERE COMMISSION IS NULL
          ![20210320_160723](https://user-images.githubusercontent.com/78403443/111862105-5fc86380-8996-11eb-93f6-5214263db84b.png)

    - NULL 값이 아닌 것들을 찾는 방법
      >>> IS NOT NULL을 이용함
      >>> SELECT * FROM EMPLOYEE
          WHERE COMMISSION IS NOT NULL
          ![20210320_160955](https://user-images.githubusercontent.com/78403443/111862149-b9309280-8996-11eb-9452-912e0f428af8.png)


**문자열 검색**

- LIKE 연산자
  - 컬럼에 저장된 문자열 중에서 LIKE 연산자에서 지정한 문자 패턴과 부분적으로 일치하면 참이 되는 연산자
  
  - 부분 문자열 검색에 사용되는 패턴
    - % : 임의의 길이의 문자열
    - _ : 글자 한자
  - 문자열 검색 예
    - Q. 부서 테이블에서 부서명(DNAME)이 H로 시작하고 n으로 끝나는 부서의 위치(loc) 검색
      >>> SELECT DNAME, LOC from DEPARTMENT
          WHERE DNAME LIKE 'H%n'
          ![20210320_161417](https://user-images.githubusercontent.com/78403443/111862227-55f33000-8997-11eb-8339-bb62804edfd0.png)
          - DNAME = 'H%n' 하게 되면 이름이 H&n 인 사람을 찾으므로 이런 경우는 꼭 LIKE 연산자 사용해서 검색

**ORDER BY 절**
- 질의문의 결과는 테이블에 입력된 순서대로 출력됨
  - 데이터의 출력 순서를 특정 속성값을 기준으로 오름차순 또는 내림차순으로 정렬해야 하는 경우가 자주 발생함
  
- ORDER BY 절
  - ORDER BY{column_name} [ASC|DESC]
    - ASC : 오름차순으로, 기본값(생략가능)
    - DESC : 내림차순, 생략불가능
  - Q. 봉급(Salary) 기준 내림차순으로 사원들의 이름, 봉급, 부서 번호 출력
    >>> SELECT ENAME, SALARY, DNO from EMPLOYEE
        ORDER BY SALARY DESC
![20210320_162210](https://user-images.githubusercontent.com/78403443/111862392-6fe14280-8998-11eb-9bb0-38b1c3d6ea19.png)

- 다중 속성 정렬
  - Q. 봉급(Salary) 기준 내림차순으로 사원들의 이름, 봉급, 부서 번호 출력
    >>> 봉급이 같은 경우에는 부서번호가 낮은 순으로(오름차순) 정렬함
    >>> SELECT ENAME, SALARY, DNO from EMPLOYEE
        ORDER BY SALARY DESC, DNO ASC
![20210320_162749](https://user-images.githubusercontent.com/78403443/111862523-39f08e00-8999-11eb-8c1f-12002fe3d819.png)
------------------------------------------------------------------------------------------------------------------------------
**데이터 삽입과 변경**

**다양한 INSERT 구문**

- 단일행 입력
  - 한번에 하나의 튜플을 테이블에 입력하는 방법
  - INSERT INTO 테이블명 [(속성명, ..., 속성명)]
    VALUES (값, ... , 값)
      - "INTO"는 생략이 가능함
      - 테이블명에 명시한 속성에 VALUES절에 지정한 값을 입력함
      - 테이블명에 속성을 명시하지 않으면 테이블 생성시 정의한 컬럼 순서와 동일한 순서로 입력함
  - Q. 실습을 위하여 사원과 같은 구조의 테이블 EMPTEST 생성
    - CREATE TABLE EMPTEST(
          ENO INT,
          ENAME, NVARCHAR(20), JOB NVARCHAR(20),
          MANAGER INT, HIREDATE DATETIME,
          SALARY INT, COMMISSION INT,
          DNO INT
      )    
      ![20210320_164519](https://user-images.githubusercontent.com/78403443/111862921-abc9d700-899b-11eb-92ee-c285ef5c2916.png)
    
    - EMPTEST 테이블에 사원 정보 삽입
    - 50, "홍길동", "staff", NULL, 2012-10-01, 500, 30, 10   
      >>> INSERT INTO EMPTEST
          VALUES(50, "홍길동", "staff", NULL, 2012-10-01, 500, 30, 10)
          
- NULL의 입력
  - 데이터를 입력하는 시점에서 해당 속성값을 모르거나, 미확정일 때 사용함
  - NOT NULL 조건이 지정된 경우 입력이 불가능함
    - 묵시적인 방법: INSERT INTO 절에 해당 속성명 생략
    - 명시적인 방법: VALUES 절에 있는 속성값에 NULL을 사용          
  
  1) EMPTEST 테이블에 묵시적인 방법을 이용하여 사원번호(51)와 사원이름('심청이')입력, 나머지는 NULL 입력
    >>> INSERT INTO EMPTEST(ENO, ENAME)
        VALUES(51, '심청이')

  2) EMPTEST 테이블에 명시적인 방법을 이용하여 사원번호(52)와 사원이름('임꺽정') 입력, 나머지는 NULL 입력
    >>> INSERT INTO emptest
        VALUES(52, '임꺽정', NULL, NULL, NULL, NULL, NULL, NULL)

- 서브 쿼리를 이용한 데이터 삽입
  - 서브 쿼리의 결과를 테이블에 삽입함
    - 한번에 여러 튜플을 넣을 수 있음
      >>> INSERT INTO 테이블
          subquery
    - 서브쿼리의 결과 집합은 INSERT 명령문에 지정된 칼럼 개수와 데이터 타입이 일치해야 함
      - 다른 테이블에 튜플로 넣고 싶을 때 주로 우리가 사용하는 방법
    - Q. 사원 테이블에서 부서번호 30인 사원들을 EMPTEST에 삽입
      >>> INSERT INTO emptest
          SELECT *
          FROM EMPLOYEE
          WHERE DNO = 30
          
- 질의 결과 테이블 만들기
  - 질의 결과를 바로 테이블 만들고 저장하기
    >>> SELECT 컬럼리스트 INTO 대상테이블
        FROM 테이블
        WHERE 조건
  - Q. 부서 테이블에서 부서번호 30인 부서의 부서번호와 부서명을 DEPTEST란 테이블로 저장
    >>> SELECT DNO, DNAME INTO DEPTEST
        FROM DEPARTMENT
        WHERE DNO = 30
  - 오라클의 경우에는 구문이 다소 다름
    >>> CREATE TABLE 테이블명
        AS
                SELECT 컬럼리스트
                FROM 테이블
                [WHERE 조건]
  1) 질의 결과로 만든 테이블은 기존테이블의 속성명과 타입을 그대로 적용함
  2) NOT NULL 조건을 그대로 적용함
  3) 다른 제약조건은 적용되지 않음

- 테이블 구조의 복사
  - 상황에 따라서 기존 테이블과 동일한 구조를 지니는 테이블을 생성할 필요가 있음
    - 구조만 복사하고 튜플들은 복사하고 싶지 않은 경우
  - SELECT ~ INTO ~ 구문을 이용함
  - WHERE 조건에 항상 거짓이 되는 조건을 기술함
    ex) 1 > 2
  - Q. DEPARTMENT의 구조만 복사하여 DEPT_COPY 테이블 생성
    >>> SELECT * INTO DEPT_COPY
        FROM DEPARTMENT
        WHERE 1 > 2
        
- 테이블의 구조 검색문
  - 오라클
    - 명령어 : DESCRIBE[DESC] 테이블명
  - MS SQL
    - 저장 프로시저 : sp_help 테이블명
    - 저장 프로시저를 수행시키기 위하여 EXEC 명령어가 필요함
  - Q. DEPTEST의 튜플들과 구조정보 검색
    >>> SELECT * FROM DEPTEST
    >>> (빈줄)
    >>> EXEC sp_help DEPTEST
![20210320_172220](https://user-images.githubusercontent.com/78403443/111863792-ebdf8880-89a0-11eb-9171-13c8b86b8925.png)
        
- VALUES를 이용한 다중행 입력
  - MS-SQL 2008 부터는 서브 쿼리가 아닌 VALUES를 이용해서도 다중행 삽입이 가능함
    >>> INSERT INTO table1
        VALUES (속성값들), (속성값들)
    >>> INSERT INTO DEPT01
        VALUES (200, 'dept001', 'seoul'), (210, 'dept002', 'sangju')
![20210320_172556](https://user-images.githubusercontent.com/78403443/111863880-5a244b00-89a1-11eb-8478-6d91950de59f.png)

**UPDATE와 DELETE**

- UPDATE 구문
  - 데이터 수정
    - UPDATE 문
      - 테이블에 저장된 데이터를 수정하기 위한 데이터 조작어
        >>> UPDATE 테이블명
            SET column = 값, ...
            [WHERE 조건]
            - WHERE절이 생략되면 테이블의 모든 행이 수정됨
    - Q. EMPTEST에 있는 모든 사원의 봉급 10% 인상
      >>> SELECT * FROM emptest
      >>> 
      >>> UPDATE emptest
      >>> SET SALARY = SALARY*1.1
      >>> 
      >>> SELECT * FROM emptest
          ![20210320_173516](https://user-images.githubusercontent.com/78403443/111864140-a623bf80-89a2-11eb-91aa-b800e5d24c79.png)
    - Q. EMPTEST에 있는 사원들 중 30번 부서에 속한 사원들의 직급 모두 staff로 변경
      >>> SELECT * FROM emptest
      >>> 
      >>> UPDATE emptest
      >>> SET JOB = 'staff'
      >>> WHERE DNO = 30
      >>> 
      >>> SELECT * FROM emptest
          ![20210320_173915](https://user-images.githubusercontent.com/78403443/111864265-395cf500-89a3-11eb-88c3-503d5797123e.png)

  - 서브 쿼리를 이용한 데이터 수정
    - UPDATE문의 SET절에서 서브 쿼리를 이용함
    - 다른 테이블에 저장된 데이터를 검색하여 한번에 여러 속성값을 수정할 수 있음
    - SET 절의 속성명은 서브쿼리의 속성명과 달라도 됨
      >>> UPDATE table
          SET 속성 1 = (SELECT ~ FROM ~ WHERE ~)
          [WHERE 조건]
          
    - Q. EMPTEST 테이블에서 사원번호 50번인 사원의 관리자번호
      - 사원테이블의 사원번호 101번의 값으로 변경
        >>> UPDATE emptest
        >>> SET MANAGER = (SELECT MANAGER FROM EMPLOYEE WHERE ENO = 101)
        >>> WHERE ENO = 50
        >>>     
        >>> SELECT *
        >>> FROM emptest
            ![20210320_174709](https://user-images.githubusercontent.com/78403443/111864453-53e39e00-89a4-11eb-8d67-bfa55e487f00.png)
 
  - 복수 속성값 변경
    - 하나 이상의 속성값 한번에 변경하기
      - SET 절에 (속성명 = 값), (속성명 = 값), ... 으로 작성함
        >>> UPDATE table
            SET 속성1 = 값, 속성2 = 값, ...
            [WHERE]조건
    - Q. EMPTEST에서 eno가 51인 튜플  
        >>> SALARY를 300으로 변경
        >>> COMMISSION은 50으로 변경
          >>> UPDATE emptest
              SET SALARY = 300, COMMISSION = 50
              WHERE eno = 51
              ![20210320_175337](https://user-images.githubusercontent.com/78403443/111864585-36fb9a80-89a5-11eb-9419-199ba34d253c.png)

- DELETE 구문
  - 데이터 삭제
    - DELETE 문
      - 테이블에 저장된 데이터 삭제를 위한 조작어
        >>> DELETE [FROM] 테이블
            [WHERE 조건]
        - WHERE 절이 생략되면 테이블의 모든 행을 삭제함

    - Q. DEPTEST에 있는 모든 정보를 삭제
      >>> DELETE DEPTEST
          ![20210320_175911](https://user-images.githubusercontent.com/78403443/111864719-fe0ff580-89a5-11eb-8c7a-e19875cfe3c9.png) 

    - Q. EMPTEST에서 급여가 400 미만인 사원 제거
      >>> DELETE emptest
          WHERE SALARY < 400
          ![20210320_180105](https://user-images.githubusercontent.com/78403443/111864764-4202fa80-89a6-11eb-8d6e-aede8c3083c0.png)

  - 서브쿼리를 이용한 데이터 삭제
    - WHERE절에서 서브 쿼리를 이용함
    - 다른 테이블에 저장된 데이터를 검색하여 한번에 여러 행을 삭제함
    - WHERE 절의 속성명은 서브 쿼리의 속성명과 달라도 됨
    
    - Q. 부서명이 Accounting인 부서에 속한 사원들을 EMPTEST 테이블에서 삭제하기
      >>> DELETE EMPTEST
          WHERE DNO = (SELECT DNO FROM DEPARTMENT WHERE DNAME = 'Accounting')
  ![20210320_180500](https://user-images.githubusercontent.com/78403443/111864858-cd7c8b80-89a6-11eb-96ea-1910d1884da1.png)
------------------------------------------------------------------------------------------------------------------------------
**트랜잭션**

**데이터베이스 회복의 기본이 되는 트랜잭션**

- 트랜잭션의 개념
  - 트랜잭션이란?
  - 트랜잭션(Transaction): 논리적인 일의 단위
    - 기본 설정
      - 하나의 SQL은 하나의 트랜잭션임
      - 여러 개의 SQL문들이 합쳐져서 하나의 트랜잭션이 될 수도 있음 
  
  - 트랜잭션의 활용
    - 항공기 예약, 은행, 신용 카드 처리, 대형 할인점
    - 대규모 데이터베이스를 수백, 수천 명 이상의 사용자들이 동시에 접근함
    - 많은 사용자들이 동시에 데이터베이스의 서로 다른 부분 또는 동일한 부분을 접근하면서 데이터베이스를 사용함
    >>> 동시성
    
    - 동시성 제어
      - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향 = 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같도록 보장함
      - 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터베이스의 일관성을 유지함
      - 여러 사용자나 여러 응용 프로그램들이 동시에 수행되어도 서로 간섭하지 못하도록 보장함
      >>> 트랜잭션 단위 동시성 제어
    
    - 회복
      - 데이터베이스를 갱신하는 도중에 시스템 고장 시에도 데이터베이스의 일관성을 유지함 >>> 트랜잭션 단위 회복
  
  - 트랜잭션이 없다면?
    1) 은행 계좌 이자 증가
      - 전체 계좌들에 대한 이자가 모두 계산되어야 함
      - 만약 일부 계좌 이자만 증가되고 컴퓨터가 다운되었다가 재가동 된다면?
        >>> 처음부터 다시 계산하면 이중 이자 계산이 됨
    2) 다양한 예약 시스템
      - 항공권, 극장 등의 예약 시스템
      - 좌석을 선점하고 돈을 내기 전에 시스템이 다운 됨
      - 돈은 내지 않았지만 좌석을 잡았기 때문에 해당 좌석은 절대 다시 잡을 수 없어짐
    3) 은행 계좌 이체: A계좌에서 100원을 빼서 B계좌에 넣기  
       UPDATE ACCOUNT
       SET BALANCE = BALANCE - 100
       WHERE ID = A
      
       >>>

       UPDATE ACCOUNT
       SET BALANCE = BALANCE + 100
       WHERE ID = B
![20210320_183532](https://user-images.githubusercontent.com/78403443/111865542-11718f80-89ab-11eb-8bd1-151151bacb6d.png)
    - 계좌 이체 시 장애발생     
       - A 통장에서 돈만 빠져 나가고 B통장에 돈이 안 들어옴
        >>> 은행이 고객의 돈을 횡령한 것이 됨
![20210320_183717](https://user-images.githubusercontent.com/78403443/111865605-6a412800-89ab-11eb-8d5b-388c4103a956.png)
    - 횡령을 피하기 위해 먼저 B 계좌에 돈을 입금...
      UPDATE ACCOUNT
       SET BALANCE = BALANCE + 100
       WHERE ID = B
      
       >>> 장애 >>>

       UPDATE ACCOUNT
       SET BALANCE = BALANCE - 100
       WHERE ID = A    
      - B 통장에서 돈이 들어 왔는데 A 통장에 돈이 안 빠짐
        >> 은행에 막대한 손실이 발생함
      - 두 개의 SQL을 모아서 하나의 트랜잭션(계좌이체 업무)으로 관리함
      - 두 DML문은 하나의 업무에 속한 작업들임
![20210320_184032](https://user-images.githubusercontent.com/78403443/111865686-c4da8400-89ab-11eb-9d74-ff07162bf045.png)
        
-트랜잭션의 특성
  - ACID
    - Atomicity 원자성
    - Consistency 일관성
    - Isolation 격리성
    - Durability 영속성        
    
    1) 원자성(Atomicity)
      >> 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(All or Nothing)을 의미함
      >> DMBS의 회복 모듈은 시스템이 다운되는 경우에, 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소함으로써 트랜잭션의 원자성을 보장함
      >> 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장함
      
    2) 일관성(Consistency)
      >> 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐
      >> 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 일관된 상태를 갖지 않을 수 있음 

    3) 격리성(Isolation)
      >> 고립성이라고도 함
      >> 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함
      >> 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
      >> DBMS의 동시성 제어 모듈이 트랜잭션의 고립성을 보장함
      >> DBMS는 응용들의 요구사항에 따라 다양한 고립 수준(Isolation Level)을 제공함

    4) 지속성(영속성)(Durability)
      >> 일단 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음
      >> 완료된 트랜잭션의 효과는 시스템이 고장 난 경우에도 데이터베이스에 반영됨
      >> DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장함

  - ACID 특성과 DB 기능
    - ACID 특성과 DB의 기능은 모두 다 연관이 있음(연관성이 높은 순서)
      - DB 회복 기능 : 원자성과 지속성에 연관됨
      - DB 동시성 제어 : 일관성과 고립성에 연관
      - 무결성 제약 조건 : 일관성과 관련
  - 트랜잭션의 상태변화
![20210320_205412](https://user-images.githubusercontent.com/78403443/111868639-71bdfc80-89be-11eb-9581-e8399831d0f8.png)

- 트랜잭션 제어문(TCL)
  - COMMIT
    - 트랜잭션의 마지막 명령어가 수행되었음을 나타냄
    - 트랜잭션에 의한 변경을 확정
    - COMMIT된 트랜잭션은 철회가 불가능함
    - COMMIT 명령문 실행하기 전에 하나의 트랜잭션 변경한 결과를 다른 트랜잭션에서 접근할 수 없도록 방지하여 일관성을 유지함
  - ROLLBACK
    - 트랜잭션의 변경을 취소하고 트랜잭션 종료
  - SAVEPOINT
    - 현재 트랜잭션에서 ROOLBACK 시킬 위치 지정
    - 대규모 트랜잭션(복수개의 명령어들로 이루어진 트랜잭션)에서 오류 발생이 전체 트랜잭션을 취소 시키는 것이 큰 부담이 될 수 있음
    - 실패한 일정부분만 취소 시키도록 함

- 트랜잭션 모드
  - MS-SQL은 3가지의 트랜잭션 모드를 지원함
    1) 자동 커밋 트랜잭션
      - 하나의 명령문이 하나의 트랜잭션이 됨
      - MS-SQL에서 기본 모드임
    2) 명시적 트랜잭션
      - 명시적으로 사용자가 트랜잭션을 정의하는 형태
      - BEGIN TRAN ~ COMMIT TRAN(또는 ROOLBACK TRAN)으로 이루어짐
    3) 묵시적 트랜잭션
      - 자동 커밋 트랜잭션의 반대되는 개념
      - 사용자가 COMMIT TRAN(또는 ROLLBACK TRAN)을 입력하기 전까지 복수 개의 명령문을 하나의 트랜잭션으로 간주함
      - BEGIN TRAN이 필요 없음
      - 묵시적 트랜잭션의 설정
        - SET IMPLICIT TRANSACTIONS {ON|OFF}
      - 트랜잭션 종료마다 사용자가 반드시 COMMIT / ROLLBACK 명령문을 실행시켜야 함
      - 고급 사용자가 아닌 이상 가능한 사용하지 않는 것이 좋음
    
- 트랜잭션 제어문(TCL) 활용
  - 간단한 트랜잭션 철회
    - Q. 실습을 위하여 DEPARTMENT 테이블 내용을 DEPT01로 복사하기
      >>> SELECT * INTO DEPT01 FROM DEPARTMENT
          SELECT * FROM DEPT01
![20210320_212628](https://user-images.githubusercontent.com/78403443/111869454-f27ef780-89c2-11eb-97ce-f7768c779a81.png)
    - Q. 트랜잭션을 시작한 후 DEPT01 테이블의 내용을 모두 지우고 트랜잭션 취소를 시켜보기
      1) 트랜잭션을 시작
      2) DEPT01 테이블 내용 지우기
        >> DEPT01 내용 보기
      3) ROLLBACK
        >> DEPT01 내용 보기
      
        >> BEGIN TRAN
        >> 
        >> DELETE DEPT01
        >> 
        >> SELECT * FROM DEPT01
        >> 
        >> ROLLBACK TRAN
        >> 
        >> SELECT * FROM DEPT01
![20210320_213045](https://user-images.githubusercontent.com/78403443/111869572-8bae0e00-89c3-11eb-9660-fbcf21fb6df6.png)

  - 오류발생에 따른 트랜잭션 철회
    - 트랜잭션을 구성하는 명령문들 중
      - 오류 발생 >> 트랜잭션 철회
      - 오류 발생하지 않음 >> 완료
        - MS-SQL에서 명령문의 오류는 @@ERROR라는 변수에 저장됨
        - T-SQL에서 IF ~ ELSE ~ 및 GOTO 같은 구문을 사용할 수 있음
    - DEPT01 테이블의 DNO는 NULL값이 올 수 없음
      - 테이블 구조정보 보는 법 : EXEC sp_help 테이블명
![20210320_213533](https://user-images.githubusercontent.com/78403443/111869768-39212180-89c4-11eb-8e4e-f3180272eafe.png)

    - 하나의 트랜잭션을 이용함
      1) DEPT01 테이블에서 부서번호 10번 튜플을 삭제함
      2) (NULL, 'PRODUCT', 'Seoul') 튜플을 삽입 >> 오류 발생
      3) 오류가 발생하면 해당 트랜잭션을 ROLLBACK함
        >>> BEGIN TRAN
        >>> 
        >>> DELETE FROM DEPT01 WHERE DNO = 10
        >>> SELECT * FROM DEPT01
        >>> 
        >>> INSERT INTO DEPT01 VALUES(NULL, 'PRODUCT', 'Seoul')
        >>> 
        >>> IF @@ERROR <> 0 GOTO ERROR_ROLLBACK
        >>> 
        >>> COMMIT TRAN
        >>> RETURN
        >>> 
        >>> ERROR_ROLLBACK:
        >>> ROLLBACK TRAN
        >>> GO
        >>> 
        >>> SELECT * FROM DEPT01
        >>> GO
 ![20210320_214145](https://user-images.githubusercontent.com/78403443/111869945-16433d00-89c5-11eb-91bb-6fa464a81252.png)

  - SAVEPOINT를 이용한 트랜잭션 부분 철회
    - 트랜잭션 내에서 SAVEPOINT의 지정
      - SAVE TRAN 저장점명
        - 트랜잭션 내에 저장점명을 다르게 하면 여러 개의 SAVEPOINT를 지정할 수 있음      
    - 저장점 위치로 취소
      - ROLLBACK TRAN 저장점명
    - 하나의 트랜잭션을 이용함
      1) DEPT01 테이블에서 부서번호 10번 튜플을 삭제함
      2) 저장점 설정함
      3) (50, 'PRODUCT', 'Seoul') 추가함
      4) 저장점으로 ROLLBACK
      5) (60, 'DESIGN', 'Jeju') 추가함
      >>> SAVEPOINT에 의하여 (50, 'PRODUCT', 'Seoul')을 삽입되지 않을 것을 알 수 있음
      >>> (60, 'DESIGN', 'Jeju')는 삽입되었음
      
        >>> BEGIN TRAN
        >>> 
        >>> DELETE FROM DEPT01 WHERE DNO = 10
        >>> 
        >>> SAVE TRAN svpoint1
        >>> 
        >>> INSERT INTO DEPT01 VALUES (50, 'PRODUCT', 'Seoul')
        >>> 
        >>> ROLLBACK TRAN svpoint1
        >>> 
        >>> INSERT INTO DEPT01 VALUES(60, 'DESIGN', 'Jeju')
        >>> 
        >>> COMMIT TRAN
        >>> GO
        >>> 
        >>> SELECT * FROM DEPT01
 ![20210320_215418](https://user-images.githubusercontent.com/78403443/111870234-d5e4be80-89c6-11eb-82ce-8d1caf5804cd.png)






